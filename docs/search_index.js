var documenterSearchIndex = {"docs":
[{"location":"ec.html#Elliptic-Curve-Arithmetic","page":"Elliptic Curves","title":"Elliptic Curve Arithmetic","text":"","category":"section"},{"location":"ec.html#Types","page":"Elliptic Curves","title":"Types","text":"","category":"section"},{"location":"ec.html","page":"Elliptic Curves","title":"Elliptic Curves","text":"EC{B}\r\n\r\nAbstractECPoint{B}\r\n\r\nECPointAffine{B}\r\n\r\nECPointJacobian{B}\r\n\r\nECPointLD{B}\r\n\r\nECMismatchException","category":"page"},{"location":"ec.html#BinaryECC.EC","page":"Elliptic Curves","title":"BinaryECC.EC","text":"EC{B}\n\nRepresents a non-supersingular elliptic curve over the binary field B.\n\nContains fields a::B and b::B, where:\n\ny^2 + xy = x^3 + ax^2 + b\n\n\n\n\n\n","category":"type"},{"location":"ec.html#BinaryECC.AbstractECPoint","page":"Elliptic Curves","title":"BinaryECC.AbstractECPoint","text":"AbstractECPoint{B}\n\nAbstract type for points on an elliptic curve defined over the binary field B.\n\n\n\n\n\n","category":"type"},{"location":"ec.html#BinaryECC.ECPointAffine","page":"Elliptic Curves","title":"BinaryECC.ECPointAffine","text":"ECPointAffine{B} <: AbstractECPoint{B}\n\nRepresents a point on an elliptic curve over the binary B. Contains fields x::B, y::B, and ec::EC{B}.\n\nE y^2 +  xy = x^3 + ax^2 + b\n\n\n\n\n\n","category":"type"},{"location":"ec.html#BinaryECC.ECPointJacobian","page":"Elliptic Curves","title":"BinaryECC.ECPointJacobian","text":"ECPointJacobian{B} <: AbstractECPoint{B}\n\nRepresents a point on an elliptic curve over the binary B. Contains fields x::B, y::B, z::B and ec::EC{B}.\n\nE y^2 +  xyz = x^3 + ax^2z^2 + bz^6\n\nEach point (x y) on the curve is represented by a set of equivalent Jacobian points, (lambda^2 x lambda^3 y lambda)  lambda in K^*  (where K^* is the binary field that the curve is based on).\n\n\n\n\n\n","category":"type"},{"location":"ec.html#BinaryECC.ECPointLD","page":"Elliptic Curves","title":"BinaryECC.ECPointLD","text":"ECPointLD{B} <: AbstractECPoint{B}\n\nRepresents a point on an elliptic curve over the binary B. Contains fields x::B, y::B, z::B and ec::EC{B}.\n\nE y^2 +  xyz = x^3z + ax^2z^2 + bz^4\n\nEach (affine) point (x y) is represented by a set of Lopez-Dahab points, (lambda x lambda^2 y lambda)  lambda in K^*  (where K^* is the binary field that the curve is based on).\n\n\n\n\n\n","category":"type"},{"location":"ec.html#BinaryECC.ECMismatchException","page":"Elliptic Curves","title":"BinaryECC.ECMismatchException","text":"ECMismatchException <: Exception\n\nIndicates that an operation has been attempted on several points that are not on the same curve.\n\n\n\n\n\n","category":"type"},{"location":"ec.html#Curve-Functions","page":"Elliptic Curves","title":"Curve Functions","text":"","category":"section"},{"location":"ec.html","page":"Elliptic Curves","title":"Elliptic Curves","text":"==(ec1::EC{B}, ec2::EC{B}) where B\r\n\r\nrepr(ec::EC)","category":"page"},{"location":"ec.html#Base.:==-Union{Tuple{B}, Tuple{EC{B},EC{B}}} where B","page":"Elliptic Curves","title":"Base.:==","text":"==(ec1::EC{B}, ec2::EC{B}) where B\n\nTwo elliptic curves are equal if they have the same parameters a and b, and are defined over the same field.\n\n\n\n\n\n","category":"method"},{"location":"ec.html#Base.repr-Tuple{EC}","page":"Elliptic Curves","title":"Base.repr","text":"repr(ec::EC)\n\nReturns a string representation of an elliptic curve equation,  \"y^2 + xy = x^3 + ax^2 + b\".\n\n\n\n\n\n","category":"method"},{"location":"ec.html#Point-Arithmetic","page":"Elliptic Curves","title":"Point Arithmetic","text":"","category":"section"},{"location":"ec.html","page":"Elliptic Curves","title":"Elliptic Curves","text":"==(p1::ECPointAffine{B}, p2::ECPointAffine{B}) where B\r\n\r\n+(p1::ECPointAffine{B}, p2::ECPointAffine{B}) where B\r\n\r\ndouble(p::ECPointAffine{B}) where B\r\n\r\n-(p::ECPointAffine{B}) where B\r\n\r\n-(p1::ECPointAffine{B}, p2::ECPointAffine{B}) where B\r\n\r\n*(p::AbstractECPoint{B}, n::Integer) where B","category":"page"},{"location":"ec.html#Base.:==-Union{Tuple{B}, Tuple{ECPointAffine{B},ECPointAffine{B}}} where B","page":"Elliptic Curves","title":"Base.:==","text":"==(p1::ECPointAffine{B}, p2::ECPointAffine{B}) where B\n\nTwo points are equal iff they have the same x and y coordinate,  and are on the same elliptic curve.\n\n\n\n\n\n","category":"method"},{"location":"ec.html#Base.:+-Union{Tuple{B}, Tuple{ECPointAffine{B},ECPointAffine{B}}} where B","page":"Elliptic Curves","title":"Base.:+","text":"+(p1::ECPointAffine{B}, p2::ECPointAffine{B}) where B\n\nReturns p_1+p_2.\n\nIf the points are not on the same curve, this will throw an ECMismatchException.\n\n\n\n\n\n","category":"method"},{"location":"ec.html#BinaryECC.double-Union{Tuple{B}, Tuple{ECPointAffine{B}}} where B","page":"Elliptic Curves","title":"BinaryECC.double","text":"double(p::ECPointAffine{B})::ECPointAffine{B} where B\n\nReturns the result of doubling the point p, using a standard method that assumes p is a random unknown point.\n\n\n\n\n\n","category":"method"},{"location":"ec.html#Base.:--Union{Tuple{B}, Tuple{ECPointAffine{B}}} where B","page":"Elliptic Curves","title":"Base.:-","text":"-(p::ECPointAffine{B}) where B\n\nReturns additive inverse of the given point, -p.\n\n\n\n\n\n","category":"method"},{"location":"ec.html#Base.:--Union{Tuple{B}, Tuple{ECPointAffine{B},ECPointAffine{B}}} where B","page":"Elliptic Curves","title":"Base.:-","text":"-(p1::AbstractECPoint, p2::AbstractECPoint)\n\nReturns p_1-p_2.\n\n\n\n\n\n","category":"method"},{"location":"ec.html#Base.:*-Union{Tuple{B}, Tuple{AbstractECPoint{B},Integer}} where B","page":"Elliptic Curves","title":"Base.:*","text":"*(p::AbstractECPoint{B}, k) where B\n\nReturns the result of the scalar multiplication p cdot k, using a default high performance method. Commutative, so that either p * k or k * p can be written, in addition to p \\cdot k or k \\cdot p. k must be an integer or a PFieldElt.\n\n\n\n\n\n","category":"method"},{"location":"ec.html#Scalar-Point-Addition","page":"Elliptic Curves","title":"Scalar Point Addition","text":"","category":"section"},{"location":"ec.html","page":"Elliptic Curves","title":"Elliptic Curves","text":"double_standard(p::ECPointAffine{B}) where B\r\n\r\ndouble_memo(p::ECPointAffine{B}) where B\r\n\r\ndouble_threaded(p::ECPointAffine{B}) where B","category":"page"},{"location":"ec.html#BinaryECC.double_standard-Union{Tuple{B}, Tuple{ECPointAffine{B}}} where B","page":"Elliptic Curves","title":"BinaryECC.double_standard","text":"double_standard(p::ECPointAffine{B})::ECPointAffine{B} where B\n\nPerforms a standard version of the point doubling routine.\n\n\n\n\n\n","category":"method"},{"location":"ec.html#BinaryECC.double_memo-Union{Tuple{B}, Tuple{ECPointAffine{B}}} where B","page":"Elliptic Curves","title":"BinaryECC.double_memo","text":"double_memo(p::ECPointAffine{B})::ECPointAffine{B} where B\n\nPerforms memoised point doubling: if the point p has previously been calculated by this routine, it will be fetched from a dictionary rather than recalculated. If the point has not yet been seen, it will be doubled with the double_standard routine and stored into a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"ec.html#BinaryECC.double_threaded-Union{Tuple{B}, Tuple{ECPointAffine{B}}} where B","page":"Elliptic Curves","title":"BinaryECC.double_threaded","text":"double_threaded(p::ECPointAffine{B})::ECPointAffine{B} where B\n\nDoubles the point p by spawning an additional thread to perform extra work on.\n\n\n\n\n\n","category":"method"},{"location":"ec.html#Scalar-Point-Multiplication","page":"Elliptic Curves","title":"Scalar Point Multiplication","text":"","category":"section"},{"location":"ec.html","page":"Elliptic Curves","title":"Elliptic Curves","text":"mult_standard_rtl(P::AbstractECPoint{B}, k::Integer) where B\r\n\r\nmult_standard_ltr(P::AbstractECPoint{B}, k::Integer) where B\r\n\r\nmult_window(P::AbstractECPoint{B}, k::Integer, w::Int) where B\r\n\r\nmult_bnaf(P::AbstractECPoint{B}, k::Integer) where B\r\n\r\nmult_memo(P::AbstractECPoint{B}, k::Integer) where B\r\n\r\nmult_bnaf_threaded(P::AbstractECPoint{B}, k::Integer) where B\r\n\r\nmult_bnaf_window(P::AbstractECPoint{B}, k::Integer, w::Int) where B\r\n\r\nmult_wnaf(P::AbstractECPoint{B}, k::Integer, w::Int) where B\r\n\r\nmult_mont_general(p::AbstractECPoint, n::Integer)\r\n\r\nmult_mont_affine(p::ECPointAffine{B}, n::Integer) where B","category":"page"},{"location":"ec.html#BinaryECC.mult_standard_rtl-Union{Tuple{B}, Tuple{AbstractECPoint{B},Integer}} where B","page":"Elliptic Curves","title":"BinaryECC.mult_standard_rtl","text":"mult_standard_rtl(P::AbstractECPoint{B}, k::Integer) where B\n\nPerforms scalar point multiplication using a right-to-left double-and-add method.\n\n\n\n\n\n","category":"method"},{"location":"ec.html#BinaryECC.mult_standard_ltr-Union{Tuple{B}, Tuple{AbstractECPoint{B},Integer}} where B","page":"Elliptic Curves","title":"BinaryECC.mult_standard_ltr","text":"mult_standard_ltr(P::AbstractECPoint{B}, k::Integer) where B\n\nPerforms scalar point multiplication using a left-to-right double-and-add method.\n\n\n\n\n\n","category":"method"},{"location":"ec.html#BinaryECC.mult_window-Union{Tuple{B}, Tuple{AbstractECPoint{B},Integer,Int64}} where B","page":"Elliptic Curves","title":"BinaryECC.mult_window","text":"mult_window(P::AbstractECPoint{B}, k::Integer, w::Int) where B\n\nPerforms scalar point multiplication using a windowed left-to-right double-and-add method.\n\n\n\n\n\n","category":"method"},{"location":"ec.html#BinaryECC.mult_bnaf-Union{Tuple{B}, Tuple{AbstractECPoint{B},Integer}} where B","page":"Elliptic Curves","title":"BinaryECC.mult_bnaf","text":"mult_bnaf(P::AbstractECPoint{B}, k::Integer) where B\n\nPerforms scalar point multiplication using a right-to-left double-and-add method with the binary NAF of k.\n\n\n\n\n\n","category":"method"},{"location":"ec.html#BinaryECC.mult_memo-Union{Tuple{B}, Tuple{AbstractECPoint{B},Integer}} where B","page":"Elliptic Curves","title":"BinaryECC.mult_memo","text":"mult_memo(P::AbstractECPoint{B}, k::Integer) where B\n\nPerforms scalar point multiplication using a right-to-left double-and-add method with the binary NAF of k. This function uses the memoised point doubling routine double_memo, and so it should only called with a known point P (i.e. one which will likely be seen again, such as a generating point).\n\n\n\n\n\n","category":"method"},{"location":"ec.html#BinaryECC.mult_bnaf_threaded-Union{Tuple{B}, Tuple{AbstractECPoint{B},Integer}} where B","page":"Elliptic Curves","title":"BinaryECC.mult_bnaf_threaded","text":"mult_bnaf_threaded(P::AbstractECPoint{B}, k::Integer) where B\n\nPerforms scalar point multiplication using a right-to-left double-and-add method with the binary NAF of k, by spawning an extra thread where useful.\n\n\n\n\n\n","category":"method"},{"location":"ec.html#BinaryECC.mult_bnaf_window-Union{Tuple{B}, Tuple{AbstractECPoint{B},Integer,Int64}} where B","page":"Elliptic Curves","title":"BinaryECC.mult_bnaf_window","text":"mult_bnaf_window(P::AbstractECPoint{B}, k::Integer, w::Int) where B\n\nPerforms scalar point multiplication using a windowed left-to-right double-and-add method with the binary NAF of k. Performs best with a window size of 8.\n\n\n\n\n\n","category":"method"},{"location":"ec.html#BinaryECC.mult_wnaf-Union{Tuple{B}, Tuple{AbstractECPoint{B},Integer,Int64}} where B","page":"Elliptic Curves","title":"BinaryECC.mult_wnaf","text":"mult_wnaf(P::AbstractECPoint{B}, k::Integer, w::Int) where B\n\nPerforms scalar point multiplication using a left-to-right double-and-add method with the width-w NAF of k. Performs best with a width of 6.\n\n\n\n\n\n","category":"method"},{"location":"ec.html#BinaryECC.mult_mont_general-Tuple{AbstractECPoint,Integer}","page":"Elliptic Curves","title":"BinaryECC.mult_mont_general","text":"mult_mont_general(p::AbstractECPoint, n::Integer)\n\nPerforms p cdot n with a fixed sequence of curve and field operations. More resistant to timing attacks than the standard double and add algorithm.\n\n\n\n\n\n","category":"method"},{"location":"ec.html#BinaryECC.mult_mont_affine-Union{Tuple{B}, Tuple{ECPointAffine{B},Integer}} where B","page":"Elliptic Curves","title":"BinaryECC.mult_mont_affine","text":"mult_mont_affine(p::ECPointAffine{B}, n::Integer) where B\n\nReturns p cdot n.\n\nMore resistant to timing attacks than the standard double and add algorithm.\n\nFast Multiplication on Elliptic Curves over GF(2^m) without Precomputation, Algorithm 2A: Montgomery Scalar Multiplication.\n\n\n\n\n\n","category":"method"},{"location":"ec.html#Additive-Identity","page":"Elliptic Curves","title":"Additive Identity","text":"","category":"section"},{"location":"ec.html","page":"Elliptic Curves","title":"Elliptic Curves","text":"iszero(p::ECPointAffine)\r\nzero(::Type{ECPointAffine{B}}, ec::EC{B}) where B\r\nzero(::Type{ECPointAffine}, ec::EC{B}) where B\r\n\r\niszero(p::ECPointJacobian)\r\nzero(::Type{ECPointJacobian{B}}, ec::EC{B}) where B\r\nzero(::Type{ECPointJacobian}, ec::EC{B}) where B\r\n\r\niszero(p::ECPointLD)\r\nzero(::Type{ECPointLD{B}}, ec::EC{B}) where B\r\nzero(::Type{ECPointLD}, ec::EC{B}) where B","category":"page"},{"location":"ec.html#Base.iszero-Tuple{ECPointAffine}","page":"Elliptic Curves","title":"Base.iszero","text":"iszero(p::ECPointAffine)\n\nReturns true if p = mathcalO, i.e it is the point at infinity.\n\n\n\n\n\n","category":"method"},{"location":"ec.html#Base.zero-Union{Tuple{B}, Tuple{Type{ECPointAffine{B}},EC{B}}} where B","page":"Elliptic Curves","title":"Base.zero","text":"zero(::Type{ECPointAffine{B}, ec::EC{B}) where B\n\nReturns an object representing the point at infinity on the given curve.\n\n\n\n\n\n","category":"method"},{"location":"ec.html#Base.zero-Union{Tuple{B}, Tuple{Type{ECPointAffine},EC{B}}} where B","page":"Elliptic Curves","title":"Base.zero","text":"zero(::Type{ECPointAffine, ec::EC{B}) where B\n\nReturns an object representing the point at infinity on the given curve.\n\n\n\n\n\n","category":"method"},{"location":"ec.html#Base.iszero-Tuple{ECPointJacobian}","page":"Elliptic Curves","title":"Base.iszero","text":"iszero(p::ECPointJacobian)\n\nReturns true if p = mathcalO, i.e it is the point at infinity.\n\n\n\n\n\n","category":"method"},{"location":"ec.html#Base.zero-Union{Tuple{B}, Tuple{Type{ECPointJacobian{B}},EC{B}}} where B","page":"Elliptic Curves","title":"Base.zero","text":"zero(::Type{ECPointJacobian{B}}, ec::EC{B}) where B\n\nReturns an object representing the point at infinity on the given curve.\n\n\n\n\n\n","category":"method"},{"location":"ec.html#Base.zero-Union{Tuple{B}, Tuple{Type{ECPointJacobian},EC{B}}} where B","page":"Elliptic Curves","title":"Base.zero","text":"zero(::Type{ECPointJacobian}, ec::EC{B}) where B\n\nReturns an object representing the point at infinity on the given curve.\n\n\n\n\n\n","category":"method"},{"location":"ec.html#Base.iszero-Tuple{ECPointLD}","page":"Elliptic Curves","title":"Base.iszero","text":"iszero(p::ECPointLD)\n\nReturns true if p = mathcalO, i.e it is the point at infinity.\n\n\n\n\n\n","category":"method"},{"location":"ec.html#Base.zero-Union{Tuple{B}, Tuple{Type{ECPointLD{B}},EC{B}}} where B","page":"Elliptic Curves","title":"Base.zero","text":"zero(::Type{ECPointLD{B}}, ec::EC{B}) where B\n\nReturns an object representing the point at infinity on the given curve.\n\n\n\n\n\n","category":"method"},{"location":"ec.html#Base.zero-Union{Tuple{B}, Tuple{Type{ECPointLD},EC{B}}} where B","page":"Elliptic Curves","title":"Base.zero","text":"zero(::Type{ECPointLD}, ec::EC{B}) where B\n\nReturns an object representing the point at infinity on the given curve.\n\n\n\n\n\n","category":"method"},{"location":"ec.html#Mixed-Representation-Functions","page":"Elliptic Curves","title":"Mixed Representation Functions","text":"","category":"section"},{"location":"ec.html","page":"Elliptic Curves","title":"Elliptic Curves","text":"+(::Type{ECPointJacobian{B}}, p1::ECPointLD{B}, p2::ECPointJacobian{B}) where B\r\n+(::Type{ECPointJacobian{B}}, p1::ECPointJacobian{B}, p2::ECPointLD{B}) where B\r\n\r\n+(::Type{ECPointLD{B}}, p1::ECPointLD{B}, p2::ECPointJacobian{B}) where B\r\n+(::Type{ECPointLD{B}}, p1::ECPointJacobian{B}, p2::ECPointLD{B}) where B\r\n\r\nconvert(::Type{ECPointAffine}, p::ECPointJacobian{B}) where B\r\nconvert(::Type{ECPointAffine}, p::ECPointLD{B}) where B\r\nconvert(::Type{ECPointJacobian}, p::ECPointAffine{B}) where B\r\nconvert(::Type{ECPointJacobian}, p::ECPointLD{B}) where B\r\nconvert(::Type{ECPointLD}, p::ECPointAffine{B}) where B\r\nconvert(::Type{ECPointLD}, p::ECPointJacobian{B}) where B","category":"page"},{"location":"ec.html#Base.:+-Union{Tuple{B}, Tuple{Type{ECPointJacobian{B}},ECPointLD{B},ECPointJacobian{B}}} where B","page":"Elliptic Curves","title":"Base.:+","text":"+(::Type{ECPointJacobian{B}}, p1::ECPointLD{B}, p2::ECPointJacobian{B}) where B\n\nReturns p_1 +p_2 in Jacobian coordinates.\n\n\n\n\n\n","category":"method"},{"location":"ec.html#Base.:+-Union{Tuple{B}, Tuple{Type{ECPointJacobian{B}},ECPointJacobian{B},ECPointLD{B}}} where B","page":"Elliptic Curves","title":"Base.:+","text":"+(::Type{ECPointJacobian{B}}, p1::ECPointJacobian{B}, p2::ECPointLD{B}) where B\n\nReturns p_1 +p_2 in Jacobian coordinates.\n\n\n\n\n\n","category":"method"},{"location":"ec.html#Base.:+-Union{Tuple{B}, Tuple{Type{ECPointLD{B}},ECPointLD{B},ECPointJacobian{B}}} where B","page":"Elliptic Curves","title":"Base.:+","text":"+(::Type{ECPointLD{B}}, p1::ECPointLD{B}, p2::ECPointJacobian{B}) where B\n\nReturns p_1 +p_2 in Lopez-Dahab coordinates.\n\n\n\n\n\n","category":"method"},{"location":"ec.html#Base.:+-Union{Tuple{B}, Tuple{Type{ECPointLD{B}},ECPointJacobian{B},ECPointLD{B}}} where B","page":"Elliptic Curves","title":"Base.:+","text":"+(::Type{ECPointLD{B}}, p1::ECPointJacobian{B}, p2::ECPointLD{B}) where B\n\nReturns p_1 +p_2 in Lopez-Dahab coordinates.\n\n\n\n\n\n","category":"method"},{"location":"ec.html#Base.convert-Union{Tuple{B}, Tuple{Type{ECPointAffine},ECPointJacobian{B}}} where B","page":"Elliptic Curves","title":"Base.convert","text":"convert(::Type{ECPointAffine}, p::ECPointJacobian{B}) where B\n\nConverts a point from Jacobian coordinates to affine coordinates.\n\n\n\n\n\n","category":"method"},{"location":"ec.html#Base.convert-Union{Tuple{B}, Tuple{Type{ECPointAffine},ECPointLD{B}}} where B","page":"Elliptic Curves","title":"Base.convert","text":"convert(::Type{ECPointAffine}, p::ECPointLD{B}) where B\n\nConverts a point from Lopez-Dahab coordinates to affine coordinates.\n\n\n\n\n\n","category":"method"},{"location":"ec.html#Base.convert-Union{Tuple{B}, Tuple{Type{ECPointJacobian},ECPointAffine{B}}} where B","page":"Elliptic Curves","title":"Base.convert","text":"convert(::Type{ECPointJacobian}, p::ECPointAffine{B}) where B\n\nConverts a point from affine coordinates to Jacobian coordinates.\n\n\n\n\n\n","category":"method"},{"location":"ec.html#Base.convert-Union{Tuple{B}, Tuple{Type{ECPointJacobian},ECPointLD{B}}} where B","page":"Elliptic Curves","title":"Base.convert","text":"convert(::Type{ECPointJacobian}, p::ECPointLD{B}) where B\n\nConverts a point from Lopez-Dahab coordinates to Jacobian coordinates.\n\n\n\n\n\n","category":"method"},{"location":"ec.html#Base.convert-Union{Tuple{B}, Tuple{Type{ECPointLD},ECPointAffine{B}}} where B","page":"Elliptic Curves","title":"Base.convert","text":"convert(::Type{ECPointLD}, p::ECPointAffine{B}) where B\n\nConverts a point from affine coordinates to Lopez-Dahab coordinates.\n\n\n\n\n\n","category":"method"},{"location":"ec.html#Base.convert-Union{Tuple{B}, Tuple{Type{ECPointLD},ECPointJacobian{B}}} where B","page":"Elliptic Curves","title":"Base.convert","text":"convert(::Type{ECPointLD}, p::ECPointJacobian{B}) where B\n\nConverts a point from Jacobian coordinates to Lopez-Dahab coordinates.\n\n\n\n\n\n","category":"method"},{"location":"ec.html#Miscellaneous-Point-Functions","page":"Elliptic Curves","title":"Miscellaneous Point Functions","text":"","category":"section"},{"location":"ec.html","page":"Elliptic Curves","title":"Elliptic Curves","text":"ECPointAffine(s::String, ec::EC{BFieldElt{D,R,T,L}}) where {D,R,T,L}\r\n\r\nisvalid(p::ECPointAffine)\r\n\r\nrepr(p::ECPointAffine)\r\n\r\nrepr(p::ECPointJacobian)\r\n\r\nrepr(p::ECPointLD)\r\n\r\nnaf","category":"page"},{"location":"ec.html#BinaryECC.ECPointAffine-Union{Tuple{L}, Tuple{T}, Tuple{R}, Tuple{D}, Tuple{String,EC{BFieldElt{D,R,T,L}}}} where L where T where R where D","page":"Elliptic Curves","title":"BinaryECC.ECPointAffine","text":"ECPointAffine(s::String, ec::EC{B}) where B\n\nConvert a hex string to a point on the given elliptic curve using the procedure in SEC 2 (version 2), section 2.3.4.\n\n\n\n\n\n","category":"method"},{"location":"ec.html#Base.isvalid-Tuple{ECPointAffine}","page":"Elliptic Curves","title":"Base.isvalid","text":"isvalid(p::ECPointAffine)\n\nReturns true if p is a point on the elliptic curve that it is associated with.\n\n\n\n\n\n","category":"method"},{"location":"ec.html#Base.repr-Tuple{ECPointAffine}","page":"Elliptic Curves","title":"Base.repr","text":"repr(p::ECPointAffine)\n\nReturns a string representation of an elliptic curve point, i.e. \"(x y)\".\n\n\n\n\n\n","category":"method"},{"location":"ec.html#Base.repr-Tuple{ECPointJacobian}","page":"Elliptic Curves","title":"Base.repr","text":"repr(p::ECPointJacobian)\n\nReturns a string representation of an elliptic curve point, \"(x y z)\".\n\n\n\n\n\n","category":"method"},{"location":"ec.html#Base.repr-Tuple{ECPointLD}","page":"Elliptic Curves","title":"Base.repr","text":"repr(p::ECPointLD)\n\nReturns a string representation of an elliptic curve point, \"(x y z)\".\n\n\n\n\n\n","category":"method"},{"location":"ec.html#BinaryECC.naf","page":"Elliptic Curves","title":"BinaryECC.naf","text":"naf(k::T) where T<:Integer\n\nComputes the binary NAF of an integer k.\n\n\n\n\n\nnaf(k::Integer, w::Int)\n\nComputes the width-w NAF of integer k.\n\n\n\n\n\n","category":"function"},{"location":"field.html#Binary-Field-Arithmetic","page":"Binary Fields","title":"Binary Field Arithmetic","text":"","category":"section"},{"location":"field.html#Types","page":"Binary Fields","title":"Types","text":"","category":"section"},{"location":"field.html","page":"Binary Fields","title":"Binary Fields","text":"BFieldElt{D,R,T,L}\r\n\r\nBFieldElt{D,R,T,L}(s::String) where {D,R,T,L}","category":"page"},{"location":"field.html#BinaryECC.BFieldElt","page":"Binary Fields","title":"BinaryECC.BFieldElt","text":"BFieldElt{D,R,T,L}\n\nRepresents an element in the binary field which has order 2^D and reduction polynomial\n\nx^D + x^r_n + cdots + x^r_0\n\nwhere R = r_n r_n-1ldots r_1 r_0 in binary. The polynomial is stored with a length L array of type T<:Unsigned words, using a StaticUInt{L,T} object (a wrapper for the type MVector{L,T} from StaticArrays).\n\nNote: binary field arithmetic has been tested with words of type UInt8, UInt16, UInt32, UInt64 and UInt128. For any other possible word types, it is advisable to perform additional testing.\n\nTypes for points in the standard fields (taken from SEC 2, table 3)  are available:\n\nBFieldElt113{T,L}\nBFieldElt131{T,L}\nBFieldElt163{T,L}\nBFieldElt193{T,L}\nBFieldElt233{T,L}\nBFieldElt239{T,L}\nBFieldElt283{T,L}\nBFieldElt409{T,L}\nBFieldElt571{T,L}\n\nEach of these fields can be easily created by the functions B113(T), B131(T), etc., which take a word type T and they return a binary field element type with the smallest value of L. The function B(D, R, T) returns similar types, but for custom fields defined for D and R.\n\n\n\n\n\n","category":"type"},{"location":"field.html#BinaryECC.BFieldElt-Union{Tuple{L}, Tuple{T}, Tuple{R}, Tuple{D}, Tuple{String}} where L where T where R where D","page":"Binary Fields","title":"BinaryECC.BFieldElt","text":"BFieldElt{D,R,T,L}(s::String) where {D,R,T,L}\n\nUsing the procedure set out in SEC 1 (version 2) 2.3.6, this converts a hex string to a field element.\n\n\n\n\n\n","category":"method"},{"location":"field.html#Arithmetic","page":"Binary Fields","title":"Arithmetic","text":"","category":"section"},{"location":"field.html#General-Arithmetic","page":"Binary Fields","title":"General Arithmetic","text":"","category":"section"},{"location":"field.html","page":"Binary Fields","title":"Binary Fields","text":"==(a::BFieldElt{D,R,T,L}, b::BFieldElt{D,R,T,L}) where {D,R,T,L}\r\n\r\n+(a::BFieldElt{D,R,T,L}, b::BFieldElt{D,R,T,L}) where {D,R,T,L}\r\n\r\n-(a::BFieldElt{D,R,T,L}, b::BFieldElt{D,R,T,L}) where {D,R,T,L}\r\n\r\n*(a::BFieldElt{D,R,T,L}, b::BFieldElt{D,R,T,L}) where {D,R,T,L}\r\n\r\ninv(a::BFieldElt{D,R,T,L}) where {D,R,T,L}\r\n\r\n/(a::BFieldElt{D,R,T,L}, b::BFieldElt{D,R,T,L}) where {D,R,T,L}\r\n\r\n^(a::BFieldElt{D,R,T,L}, b::Integer) where {D,R,T,L}\r\n\r\nsquare(a::BFieldElt{D,R,T,L}) where {D,R,T,L}\r\n\r\nsqrt(a::BFieldElt{D,R,T,L}) where {D,R,T,L}","category":"page"},{"location":"field.html#Base.:==-Union{Tuple{L}, Tuple{T}, Tuple{R}, Tuple{D}, Tuple{BFieldElt{D,R,T,L},BFieldElt{D,R,T,L}}} where L where T where R where D","page":"Binary Fields","title":"Base.:==","text":"==(a::BFieldElt{D,R,T,L}, b::BFieldElt{D,R,T,L}) where {D,R,T,L}\n\nReturns true if a and b represent the same field element,  and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"field.html#Base.:+-Union{Tuple{L}, Tuple{T}, Tuple{R}, Tuple{D}, Tuple{BFieldElt{D,R,T,L},BFieldElt{D,R,T,L}}} where L where T where R where D","page":"Binary Fields","title":"Base.:+","text":"+(a::BFieldElt{D,R,T,L}, b::BFieldElt{D,R,T,L}) where {D,R,T,L}\n\nReturns a new element which is the result of a+b.\n\n\n\n\n\n","category":"method"},{"location":"field.html#Base.:--Union{Tuple{L}, Tuple{T}, Tuple{R}, Tuple{D}, Tuple{BFieldElt{D,R,T,L},BFieldElt{D,R,T,L}}} where L where T where R where D","page":"Binary Fields","title":"Base.:-","text":"-(a::BFieldElt{D,R,T,L}, b::BFieldElt{D,R,T,L}) where {D,R,T,L}\n\nReturns a new element which is the result of a-b.\n\n\n\n\n\n","category":"method"},{"location":"field.html#Base.:*-Union{Tuple{L}, Tuple{T}, Tuple{R}, Tuple{D}, Tuple{BFieldElt{D,R,T,L},BFieldElt{D,R,T,L}}} where L where T where R where D","page":"Binary Fields","title":"Base.:*","text":"*(a::BFieldElt{D,R,T,L}, b::BFieldElt{D,R,T,L}) where {D,R,T,L}\n\nReturns a new element which is the result of a cdot b. This is the default multiplication routine for binary field arithmetic, chosen to have high performance.\n\n\n\n\n\n","category":"method"},{"location":"field.html#Base.inv-Union{Tuple{L}, Tuple{T}, Tuple{R}, Tuple{D}, Tuple{BFieldElt{D,R,T,L}}} where L where T where R where D","page":"Binary Fields","title":"Base.inv","text":"inv(a::BFieldElt{D,R,T,L}) where {D,R,T,L}\n\nReturns a new element b such that a b  1 in the field represented by D and R.\n\n\n\n\n\n","category":"method"},{"location":"field.html#Base.:/-Union{Tuple{L}, Tuple{T}, Tuple{R}, Tuple{D}, Tuple{BFieldElt{D,R,T,L},BFieldElt{D,R,T,L}}} where L where T where R where D","page":"Binary Fields","title":"Base.:/","text":"/(a::BFieldElt{D,R,T,L}, b::BFieldElt{D,R,T,L}) where {D,R,T,L}\n\nReturns a new element which is the result of fracab.\n\n\n\n\n\n","category":"method"},{"location":"field.html#Base.:^-Union{Tuple{L}, Tuple{T}, Tuple{R}, Tuple{D}, Tuple{BFieldElt{D,R,T,L},Integer}} where L where T where R where D","page":"Binary Fields","title":"Base.:^","text":"^(a::BFieldElt{D,R,T,L}, b::Integer) where {D,R,T,L}\n\nReturns a new element which is the result of a^b. If squaring is required, i.e. b==2, it is faster to call square(a) directly.\n\n\n\n\n\n","category":"method"},{"location":"field.html#BinaryECC.square-Union{Tuple{L}, Tuple{T}, Tuple{R}, Tuple{D}, Tuple{BFieldElt{D,R,T,L}}} where L where T where R where D","page":"Binary Fields","title":"BinaryECC.square","text":"square(a::BFieldElt{D,R,T,L}) where {D,R,T,L}\n\nReturns a new element which is the result of a^2, using the default routine for high performance.\n\n\n\n\n\n","category":"method"},{"location":"field.html#Base.sqrt-Union{Tuple{L}, Tuple{T}, Tuple{R}, Tuple{D}, Tuple{BFieldElt{D,R,T,L}}} where L where T where R where D","page":"Binary Fields","title":"Base.sqrt","text":"sqrt(a::BFieldElt{D,R,T,L}) where {D,R,T,L}\n\nReturns b such that b^2 equiv a.\n\n\n\n\n\n","category":"method"},{"location":"field.html#Multiplication","page":"Binary Fields","title":"Multiplication","text":"","category":"section"},{"location":"field.html","page":"Binary Fields","title":"Binary Fields","text":"mult_shiftandadd(a::BFieldElt{D,R,T,L}, b::BFieldElt{D,R,T,L}) where {D,R,T,L}\r\n\r\nmult_shiftandadd_window(a::BFieldElt{D,R,T,L}, b::BFieldElt{D,R,T,L}, w::Int) where {D,R,T,L}\r\n\r\nmult_threaded(a::BFieldElt{D,R,T,L}, b::BFieldElt{D,R,T,L}) where {D,R,T,L}\r\n\r\nmult_threaded_window(a::BFieldElt{D,R,T,L}, b::BFieldElt{D,R,T,L}, w::Int) where {D,R,T,L}\r\n\r\nmult_ownreduce(a::BFieldElt{D,R,T,L}, b::BFieldElt{D,R,T,L}) where {D,R,T,L}\r\n\r\nmult_comb_rtl(a::BFieldElt{D,R,T,L}, b::BFieldElt{D,R,T,L}) where {D,R,T,L}\r\n\r\nmult_comb_ltr(a::BFieldElt{D,R,T,L}, b::BFieldElt{D,R,T,L}) where {D,R,T,L}\r\n\r\nmult_comb_window(a::BFieldElt{D,R,T,L}, b::BFieldElt{D,R,T,L}, window::Int) where {D,R,T,L}\r\n\r\nsquare_standard(a::BFieldElt{D,R,T,L}) where {D,R,T,L}\r\n\r\nsquare_window(a::BFieldElt{D,R,T,L}, window::Int) where {D,R,T,L}","category":"page"},{"location":"field.html#BinaryECC.mult_shiftandadd-Union{Tuple{L}, Tuple{T}, Tuple{R}, Tuple{D}, Tuple{BFieldElt{D,R,T,L},BFieldElt{D,R,T,L}}} where L where T where R where D","page":"Binary Fields","title":"BinaryECC.mult_shiftandadd","text":"mult_shiftandadd(a::BFieldElt{D,R,T,L}, b::BFieldElt{D,R,T,L}) where {D,R,T,L}\n\nBinary field multiplication using a right-to-left shift-and-add method.\n\n\n\n\n\n","category":"method"},{"location":"field.html#BinaryECC.mult_shiftandadd_window-Union{Tuple{L}, Tuple{T}, Tuple{R}, Tuple{D}, Tuple{BFieldElt{D,R,T,L},BFieldElt{D,R,T,L},Int64}} where L where T where R where D","page":"Binary Fields","title":"BinaryECC.mult_shiftandadd_window","text":"mult_shiftandadd_window(a::BFieldElt{D,R,T,L}, b::BFieldElt{D,R,T,L}, window::Int) where {D,R,T,L}\n\nBinary field multiplication using a right-to-left shift-and-add method with a window size of window. The optimal window size for this routine is 4.\n\n\n\n\n\n","category":"method"},{"location":"field.html#BinaryECC.mult_threaded-Union{Tuple{L}, Tuple{T}, Tuple{R}, Tuple{D}, Tuple{BFieldElt{D,R,T,L},BFieldElt{D,R,T,L}}} where L where T where R where D","page":"Binary Fields","title":"BinaryECC.mult_threaded","text":"mult_threaded(a::BFieldElt{D,R,T,L}, b::BFieldElt{D,R,T,L}) where {D,R,T,L}\n\nBinary field multiplication using a right-to-left shift-and-add method, by spawning an additional thread.\n\n\n\n\n\n","category":"method"},{"location":"field.html#BinaryECC.mult_threaded_window-Union{Tuple{L}, Tuple{T}, Tuple{R}, Tuple{D}, Tuple{BFieldElt{D,R,T,L},BFieldElt{D,R,T,L},Int64}} where L where T where R where D","page":"Binary Fields","title":"BinaryECC.mult_threaded_window","text":"mult_threaded_window(a::BFieldElt{D,R,T,L}, b::BFieldElt{D,R,T,L}, w::Int) where {D,R,T,L}\n\nBinary field multiplication using a windowed right-to-left shift-and-add method, by spawning an additional thread.\n\n\n\n\n\n","category":"method"},{"location":"field.html#BinaryECC.mult_ownreduce-Union{Tuple{L}, Tuple{T}, Tuple{R}, Tuple{D}, Tuple{BFieldElt{D,R,T,L},BFieldElt{D,R,T,L}}} where L where T where R where D","page":"Binary Fields","title":"BinaryECC.mult_ownreduce","text":"mult_ownreduce(a::BFieldElt{D,R,T,L}, b::BFieldElt{D,R,T,L}) where {D,R,T,L}\n\nBinary field multiplication using a windowed right-to-left shift-and-add method, in which reduction is performed alongside multiplication.\n\n\n\n\n\n","category":"method"},{"location":"field.html#BinaryECC.mult_comb_rtl-Union{Tuple{L}, Tuple{T}, Tuple{R}, Tuple{D}, Tuple{BFieldElt{D,R,T,L},BFieldElt{D,R,T,L}}} where L where T where R where D","page":"Binary Fields","title":"BinaryECC.mult_comb_rtl","text":"mult_comb_rtl(a::BFieldElt{D,R,T,L}, b::BFieldElt{D,R,T,L}) where {D,R,T,L}\n\nBinary field multiplication using a right-to-left comb method.\n\n\n\n\n\n","category":"method"},{"location":"field.html#BinaryECC.mult_comb_ltr-Union{Tuple{L}, Tuple{T}, Tuple{R}, Tuple{D}, Tuple{BFieldElt{D,R,T,L},BFieldElt{D,R,T,L}}} where L where T where R where D","page":"Binary Fields","title":"BinaryECC.mult_comb_ltr","text":"mult_comb_ltr(a::BFieldElt{D,R,T,L}, b::BFieldElt{D,R,T,L}) where {D,R,T,L}\n\nBinary field multiplication using a left-to-right comb method.\n\n\n\n\n\n","category":"method"},{"location":"field.html#BinaryECC.mult_comb_window-Union{Tuple{L}, Tuple{T}, Tuple{R}, Tuple{D}, Tuple{BFieldElt{D,R,T,L},BFieldElt{D,R,T,L},Int64}} where L where T where R where D","page":"Binary Fields","title":"BinaryECC.mult_comb_window","text":"mult_comb_window(a::BFieldElt{D,R,T,L}, b::BFieldElt{D,R,T,L}, window::Int) where {D,R,T,L}\n\nBinary field multiplication using a windowed left-to-right comb method. Performs best with a window size of 4.\n\n\n\n\n\n","category":"method"},{"location":"field.html#BinaryECC.square_standard-Union{Tuple{L}, Tuple{T}, Tuple{R}, Tuple{D}, Tuple{BFieldElt{D,R,T,L}}} where L where T where R where D","page":"Binary Fields","title":"BinaryECC.square_standard","text":"square_standard(a::BFieldElt{D,R,T,L}) where {D,R,T,L}\n\nBinary field squaring performed by shifting each bit b_i left by i.\n\n\n\n\n\n","category":"method"},{"location":"field.html#BinaryECC.square_window-Union{Tuple{L}, Tuple{T}, Tuple{R}, Tuple{D}, Tuple{BFieldElt{D,R,T,L},Int64}} where L where T where R where D","page":"Binary Fields","title":"BinaryECC.square_window","text":"square_window(a::BFieldElt{D,R,T,L}, window::Int) where {D,R,T,L}\n\nBinary field squaring performed with a windowed method, in which the square of each size window block is calculated upfront. Performs best with a window size of 4.\n\n\n\n\n\n","category":"method"},{"location":"field.html#Reduction","page":"Binary Fields","title":"Reduction","text":"","category":"section"},{"location":"field.html","page":"Binary Fields","title":"Binary Fields","text":"reduce(a::BFieldElt{D,R,T,L}) where {D,R,T,L}\r\n\r\nBinaryECC.@fastreduce","category":"page"},{"location":"field.html#Base.reduce-Union{Tuple{L}, Tuple{T}, Tuple{R}, Tuple{D}, Tuple{BFieldElt{D,R,T,L}}} where L where T where R where D","page":"Binary Fields","title":"Base.reduce","text":"reduce(a::BFieldElt{D,R,T,L}) where {D,R,T,L}\n\nReturns the least element b, such that a equiv b in the field represented by D and R.\n\n\n\n\n\n","category":"method"},{"location":"field.html#BinaryECC.@fastreduce","page":"Binary Fields","title":"BinaryECC.@fastreduce","text":"@fastreduce(D,R)\n\nA macro to produce a specialised reduction function for the binary field denoted by D and R. It is strongly recommended this is run for any new user-defined fields, as it achieves signficantly higher performance than the generic reduction routine.\n\n\n\n\n\n","category":"macro"},{"location":"field.html#Miscellaneous-Arithmetic","page":"Binary Fields","title":"Miscellaneous Arithmetic","text":"","category":"section"},{"location":"field.html","page":"Binary Fields","title":"Binary Fields","text":"iszero(a::BFieldElt)\r\n\r\nzero(::Type{BFieldElt{D,R,T,L}}) where {D,R,T,L}\r\n\r\nisone(a::BFieldElt)\r\n\r\none(::Type{BFieldElt{D,R,T,L}}) where {D,R,T,L}","category":"page"},{"location":"field.html#Base.iszero-Tuple{BFieldElt}","page":"Binary Fields","title":"Base.iszero","text":"iszero(a::BFieldElt)\n\nReturns true if a is the zero element of the binary field represented by D and R,  and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"field.html#Base.zero-Union{Tuple{L}, Tuple{T}, Tuple{R}, Tuple{D}, Tuple{Type{BFieldElt{D,R,T,L}}}} where L where T where R where D","page":"Binary Fields","title":"Base.zero","text":"zero(::Type{BFieldElt{D,R,T,L}}) where {D,R,T,L}\n\nReturns the zero element (additive identity) of the specified field.\n\n\n\n\n\n","category":"method"},{"location":"field.html#Base.isone-Tuple{BFieldElt}","page":"Binary Fields","title":"Base.isone","text":"isone(a::BFieldElt)\n\nReturns true if a is equal to one (multiplicative identity), and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"field.html#Base.one-Union{Tuple{L}, Tuple{T}, Tuple{R}, Tuple{D}, Tuple{Type{BFieldElt{D,R,T,L}}}} where L where T where R where D","page":"Binary Fields","title":"Base.one","text":"one(::Type{BFieldElt{D,R,T,L}}) where {D,R,T,L}\n\nReturns element one (multiplicative identity) of the specified field.\n\n\n\n\n\n","category":"method"},{"location":"field.html#Miscellaneous-Functions","page":"Binary Fields","title":"Miscellaneous Functions","text":"","category":"section"},{"location":"field.html","page":"Binary Fields","title":"Binary Fields","text":"random(::Type{BFieldElt{D,R,T,L}}) where {D,R,T,L}\r\n\r\nconvert(::Type{BigInt}, a::BFieldElt)","category":"page"},{"location":"field.html#BinaryECC.random-Union{Tuple{L}, Tuple{T}, Tuple{R}, Tuple{D}, Tuple{Type{BFieldElt{D,R,T,L}}}} where L where T where R where D","page":"Binary Fields","title":"BinaryECC.random","text":"random(::Type{BFieldElt{D,R,T,L}}) where {D,R,T,L}\n\nReturns a random element of the specified field.\n\n\n\n\n\n","category":"method"},{"location":"field.html#Base.convert-Tuple{Type{BigInt},BFieldElt}","page":"Binary Fields","title":"Base.convert","text":"convert(::Type{BigInt}, a::BFieldElt)\n\nConverts the given field point to a number (of type BigInt), following the procedure  set out in SEC 1 (version 2) 2.3.9.\n\n\n\n\n\n","category":"method"},{"location":"index.html#BinaryECC.jl","page":"Home","title":"BinaryECC.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Elliptic curve cryptography using binary fields.","category":"page"},{"location":"index.html#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Finite binary field arithmetic\nElliptic curve arithmetic\nCryptographic primitives","category":"page"},{"location":"crypto.html#Cryptographic-Primitives","page":"Cryptographic Primitives","title":"Cryptographic Primitives","text":"","category":"section"},{"location":"crypto.html#Prime-Order-Fields","page":"Cryptographic Primitives","title":"Prime Order Fields","text":"","category":"section"},{"location":"crypto.html","page":"Cryptographic Primitives","title":"Cryptographic Primitives","text":"PFieldElt","category":"page"},{"location":"crypto.html#BinaryECC.PFieldElt","page":"Cryptographic Primitives","title":"BinaryECC.PFieldElt","text":"PFieldElt\n\nRepresents an element of a prime order field, with the named field value::BigInt holding the element itself, and p::BigInt holding the field order.\n\nSupports all standard arithmetic operations, such as ==, +, -, *, /, inv, ^, isone, iszero, one, zero, isvalid.\n\n\n\n\n\n","category":"type"},{"location":"crypto.html#Curve-Domain-Parameters","page":"Cryptographic Primitives","title":"Curve Domain Parameters","text":"","category":"section"},{"location":"crypto.html","page":"Cryptographic Primitives","title":"Cryptographic Primitives","text":"CurveDomainParams{B}\r\n\r\nisvalid(T::CurveDomainParams{B}, t::Int) where B","category":"page"},{"location":"crypto.html#BinaryECC.CurveDomainParams","page":"Cryptographic Primitives","title":"BinaryECC.CurveDomainParams","text":"CurveDomainParams{B}\n\nRepresents the elliptic curve domain parameters for elliptic curve groups defined over binary field B,  as described in SEC 1 (version 2), 3.1.2.\n\nIt contains three fields:\n\nG::ECPointAffine{B}, a generating point, in affine coordinates\nn::BigInt, the order of G (i.e. the smallest n satisfying G cdot n = mathcalO)\nh::BigInt, the cofactor, h = E(mathbbF_2^m)  n\n\nThe other elements of the septuple described in 3.1.2 are accessible through the fields of G.\n\nSeveral standard curves domain parameters (taken from SEC 2, section 3) can be created by calling the following functions with a word type T:\n\nSECT163K1(T::Type{U}) where U<:Unsigned\nSECT163R1(T::Type{U}) where U<:Unsigned\nSECT233K1(T::Type{U}) where U<:Unsigned\nSECT233R1(T::Type{U}) where U<:Unsigned\nSECT283K1(T::Type{U}) where U<:Unsigned\nSECT283R1(T::Type{U}) where U<:Unsigned\nSECT409K1(T::Type{U}) where U<:Unsigned\nSECT409R1(T::Type{U}) where U<:Unsigned\nSECT571K1(T::Type{U}) where U<:Unsigned\nSECT571R1(T::Type{U}) where U<:Unsigned\n\n\n\n\n\n","category":"type"},{"location":"crypto.html#Base.isvalid-Union{Tuple{B}, Tuple{CurveDomainParams{B},Int64}} where B","page":"Cryptographic Primitives","title":"Base.isvalid","text":"isvalid(T::CurveDomainParams{B}, t::Int) where B\n\nReturns true if the curve domain parameters T meet the security level t,  using the procedure in SEC 1 (version 2) 3.1.2.2.1, and false otherwise.\n\nNote: does not currently perform step 6 (checking that n is prime).\n\n\n\n\n\n","category":"method"},{"location":"crypto.html#Elliptic-Curve-Key-Pairs","page":"Cryptographic Primitives","title":"Elliptic Curve Key Pairs","text":"","category":"section"},{"location":"crypto.html","page":"Cryptographic Primitives","title":"Cryptographic Primitives","text":"ECKeyPair{B}\r\n\r\ngenerate_keypair(T::CurveDomainParams{B}) where B\r\n\r\nisvalid(T::CurveDomainParams{B}, Q::ECPointAffine{B}) where B","category":"page"},{"location":"crypto.html#BinaryECC.ECKeyPair","page":"Cryptographic Primitives","title":"BinaryECC.ECKeyPair","text":"ECKeyPair{B}\n\nRepresents an elliptic curve key pair (described in SEC 1, version 2, 3.2) with fields d and Q (where Q = d cdot G, and G is the generator of the curve domain paramters used to generate this key pair). Contains named fields d::PFieldElt and Q::ECPointAffine{B}.\n\n\n\n\n\n","category":"type"},{"location":"crypto.html#BinaryECC.generate_keypair-Union{Tuple{B}, Tuple{CurveDomainParams{B}}} where B","page":"Cryptographic Primitives","title":"BinaryECC.generate_keypair","text":"generate_keypair(T::CurveDomainParams{B}) where B\n\nGnerates a new random ECKeyPair associated with T, as described in SEC 1 (version 2) 3.2.1.\n\n\n\n\n\n","category":"method"},{"location":"crypto.html#Base.isvalid-Union{Tuple{B}, Tuple{CurveDomainParams{B},ECPointAffine{B}}} where B","page":"Cryptographic Primitives","title":"Base.isvalid","text":"isvalid(T::CurveDomainParams{B}, Q::ECPointAffine{B}) where B\n\nReturns true if Q is a valid public key associated with the curve domain  parameters T, using the procedure in SEC 1 (version 2) 3.2.2.1, and false  otherwise.\n\n\n\n\n\n","category":"method"},{"location":"crypto.html#ECDSA","page":"Cryptographic Primitives","title":"ECDSA","text":"","category":"section"},{"location":"crypto.html","page":"Cryptographic Primitives","title":"Cryptographic Primitives","text":"ECDSASignature\r\n\r\necdsa_sign(T::CurveDomainParams{B}, U::ECKeyPair{B}, M::String) where B\r\n\r\necdsa_verify(T::CurveDomainParams{B}, Q::ECPointAffine{B}, sig::ECDSASignature, M::String) where B","category":"page"},{"location":"crypto.html#BinaryECC.ECDSASignature","page":"Cryptographic Primitives","title":"BinaryECC.ECDSASignature","text":"ECDSASignature\n\nRepresents a signature produced by ECDSA (Elliptic Curve DSA), with the fields r::PFieldElt and s::PFieldElt.\n\n\n\n\n\n","category":"type"},{"location":"crypto.html#BinaryECC.ecdsa_sign-Union{Tuple{B}, Tuple{CurveDomainParams{B},ECKeyPair{B},String}} where B","page":"Cryptographic Primitives","title":"BinaryECC.ecdsa_sign","text":"ecdsa_sign(T::CurveDomainParams{B}, U::ECKeyPair{B}, M::String) where B\n\nCreates an ECDSASignature using the key pair U (associated with the curve  domain parameters T) for the message M.\n\nThis follows the signing  procedure described in SEC 1 (version 2) 4.1.3.\n\n\n\n\n\n","category":"method"},{"location":"crypto.html#BinaryECC.ecdsa_verify-Union{Tuple{B}, Tuple{CurveDomainParams{B},ECPointAffine{B},ECDSASignature,String}} where B","page":"Cryptographic Primitives","title":"BinaryECC.ecdsa_verify","text":"ecdsa_verify(T::CurveDomainParams{B}, Q::ECPointAffine{B}, sig::ECDSASignature, M::String) where B\n\nReturns true if sig is valid signature for message M and  public key Q (associated with curve domain parameters T), following the  verifying operation described in SEC 1 (version 2) 4.1.4, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"crypto.html#ECDH","page":"Cryptographic Primitives","title":"ECDH","text":"","category":"section"},{"location":"crypto.html","page":"Cryptographic Primitives","title":"Cryptographic Primitives","text":"ecdh_calculate(T::CurveDomainParams{B}, dU::PFieldElt, QV::ECPointAffine{B}) where B\r\n\r\necdh_deployment1(T::CurveDomainParams)\r\n\r\necdh_deployment2(T::CurveDomainParams{B}, QV::ECPointAffine{B}) where B\r\n\r\necdh_agreement(T::CurveDomainParams{B}, ukey::ECKeyPair{B}, QV::ECPointAffine{B}) where B","category":"page"},{"location":"crypto.html#BinaryECC.ecdh_calculate-Union{Tuple{B}, Tuple{CurveDomainParams{B},PFieldElt,ECPointAffine{B}}} where B","page":"Cryptographic Primitives","title":"BinaryECC.ecdh_calculate","text":"ecdh_calculate(T::CurveDomainParams{B}, dU::PFieldElt, QV::ECPointAffine{B}) where B\n\nCalculates the shared secret value for entity \"U\"'s private key  ({dU) and entity \"V\"'s public key (QV), which are  associated with curve domain parameters T.\n\nThis follows the procedure described in SEC 1 (version 2) 3.3.1.\n\n\n\n\n\n","category":"method"},{"location":"crypto.html#BinaryECC.ecdh_deployment1-Tuple{CurveDomainParams}","page":"Cryptographic Primitives","title":"BinaryECC.ecdh_deployment1","text":"ecdh_deployment1(T::CurveDomainParams)\n\nPerforms the first stage of the ECDH deployment operation (described in SEC 1,  version 2, 6.1.2) from the perspective of entity \"U\".\n\n\n\n\n\n","category":"method"},{"location":"crypto.html#BinaryECC.ecdh_deployment2-Union{Tuple{B}, Tuple{CurveDomainParams{B},ECPointAffine{B}}} where B","page":"Cryptographic Primitives","title":"BinaryECC.ecdh_deployment2","text":"ecdh_deployment2(T::CurveDomainParams{B}, QV::ECPointAffine{B}) where B\n\nPerforms the second stage of the ECDH deployment operation (described in SEC 1,  version 2, 6.1.2) from the perspective of entity \"U\", using entity \"V\"'s  public key (QV).\n\n\n\n\n\n","category":"method"},{"location":"crypto.html#BinaryECC.ecdh_agreement-Union{Tuple{B}, Tuple{CurveDomainParams{B},ECKeyPair{B},ECPointAffine{B}}} where B","page":"Cryptographic Primitives","title":"BinaryECC.ecdh_agreement","text":"ecdh_agreement(T::CurveDomainParams{B}, ukey::ECKeyPair{B}, QV::ECPointAffine{B}) where B\n\nThis performs the ECDH key agreement operation as described in SEC 1 (version 2) 6.1.3.\n\nIt is performed from the perspective of entity \"U\", using their ECKeyPair ukey and the public key of entity \"V\" (QV).\n\n\n\n\n\n","category":"method"}]
}
